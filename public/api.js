(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var fs;



SupAPI.registerPlugin('typescript', 'XRegExp ', {
  code: "declare var XRegExp;",
  defs: "// Type definitions for XRegExp 2.0.0\r\n// Project: http://xregexp.com\r\n// Definitions by: Bart van der Schoor <https://github.com/Bartvds>\r\n// Definitions: https://github.com/borisyankov/DefinitelyTyped\r\n\r\ndeclare module 'xregexp' {\r\n\t// scopes: 'default', 'class', or 'all'\r\n\t/*\r\n\t Native flags:\r\n\t g - global\r\n\t i - ignore case\r\n\t m - multiline anchors\r\n\t y - sticky (Firefox 3+)\r\n\t Additional XRegExp flags:\r\n\t n - explicit capture\r\n\t s - dot matches all (aka singleline)\r\n\t x - free-spacing and line comments (aka extended)\r\n\t */\r\n\texport interface TokenOpts {\r\n\t\tscope?: string;\r\n\t\ttrigger?: () => boolean;\r\n\t\tcustomFlags?: string;\r\n\t}\r\n\r\n\texport function XRegExp(pattern: string, flags?: string): RegExp;\r\n\texport function XRegExp(pattern: RegExp): RegExp;\r\n\r\n\texport module XRegExp {\r\n\t\tfunction addToken(regex: RegExp, handler: (matchArr: RegExpExecArray, scope: string) => string, options?: TokenOpts): void;\r\n\r\n\t\tfunction build(pattern: string, subs: string[], flags?: string): RegExp;\r\n\t\tfunction cache(pattern: string, flags?: string): RegExp;\r\n\t\tfunction escape(str: string): string;\r\n\t\tfunction exec(str: string, regex: RegExp, pos?: number, sticky?: boolean): RegExpExecArray;\r\n\t\tfunction forEach(str: string, regex: RegExp, callback: (matchArr: RegExpExecArray, index: number, input: string, regexp: RegExp) => void, context?: Object): any;\r\n\t\tfunction globalize(regex: RegExp): RegExp;\r\n\r\n\t\tfunction install(options: string): void;\r\n\t\tfunction install(options: Object): void;\r\n\r\n\t\tfunction isInstalled(feature: string): boolean;\r\n\t\tfunction isRegExp(value: any): boolean;\r\n\t\tfunction matchChain(str: string, chain: RegExp[]): string[];\r\n\t\tfunction matchChain(str: string, chain: { regex: RegExp; backref: string }[]): string[];\r\n\t\tfunction matchChain(str: string, chain: { regex: RegExp; backref: number }[]): string[];\r\n\t\tfunction matchRecursive(str: string, left: string, right: string, flags?: string, options?: Object): string[];\r\n\r\n\t\tfunction replace(str: string, search: string, replacement: string, scope?: string): string;\r\n\t\tfunction replace(str: string, search: string, replacement: Function, scope?: string): string;\r\n\t\tfunction replace(str: string, search: RegExp, replacement: string, scope?: string): string;\r\n\t\tfunction replace(str: string, search: RegExp, replacement: Function, scope?: string): string;\r\n\r\n\t\tfunction split(str: string, separator: string, limit?: number): string[];\r\n\t\tfunction split(str: string, separator: RegExp, limit?: number): string[];\r\n\r\n\t\tfunction test(str: string, regex: RegExp, pos?: number, sticky?: boolean): boolean;\r\n\r\n\t\tfunction uninstall(options: Object): void;\r\n\t\tfunction uninstall(options: string): void;\r\n\r\n\t\tfunction union(patterns: string[], flags?: string): RegExp;\r\n\t\tvar version: string;\r\n\t}\r\n}\r\n\r\ndeclare var XRegExp;"
});



},{}]},{},[1]);
